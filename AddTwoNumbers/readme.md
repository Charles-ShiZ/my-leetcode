# 力扣提交记录：
+ 执行用时：128 ms, 在所有 TypeScript 提交中击败了95.50%的用户
+ 内存消耗：43.1 MB, 在所有 TypeScript 提交中击败了41.02%的用户
# 思路：
主要还是使用递归的思想，

将两个链表逐层的值相加，相应的next放入递归函数反复执行。

关键在于，要把两数相加的进位闯入递归函数。

然后还要分情况处理边缘情况：
1. 两个链表的next都为null
2. 其中一个链表的next为null

情况1: 表示两个链表所有的数都已经相加完毕，如果有进位，就返回值为1的listnode，如果无进位，返回null
情况2: 表示其中一个链表比另一个链表有更高的位数，这时需要给低位数的链表补0位，使两个链表的层数对齐，最终都会变成情况1。


